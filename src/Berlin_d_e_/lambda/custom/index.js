// Author: Mohamed Megahed
// blueprint code for intents generated by SkillCode. based on the Fact blueprint.


'use strict'; //Optional, but allows vars etc for ES6

const ndeEvents = {

    //Called after the response is built but before it is returned to the Alexa service. Calls :saveState.
    RESPONSE_READY : ':responseReady',


    DELEGATE : ':delegate',


    //old ones

    //this.emit(':tell', speechOutput);
    TELL : ':tell',

    //
    //use:
    //this.emit(':ask', speechOutput, repromptSpeech);
    ASK : ':ask',

    SPEAK : ':speak',

    //this.emit(':askWithCard', speechOutput, repromptSpeech, cardTitle, cardContent, imageObj);
    ASK_WITH_CARD : ':askWithCard',

    //this.emit(':tellWithCard', speechOutput, cardTitle, cardContent, imageObj);
    TELL_WITH_CARD : ':tellWithCard',


    TELL_WITH_ACCT_CARD :'tellWithLinkAccountCard',
    ASK_WITH_ACCT_CARD: ':askWithLinkAccountCard',



    //this.emit(':saveState', false); // Handles saving the contents of this.attributes and the current handler state to DynamoDB and then sends the previously built response to the Alexa service. Override if you wish to use a different persistence provider. The second attribute is optional and can be set to ‘true’ to force saving.
    SAVE_STATE : ':saveState',

    // Called if there is an error while saving state. Override to handle any errors yourself.
    //this.emit(':saveStateError');




// ASK_FOR_PERMISSIONS_CONSENT:
}

const languageStrings = {
    'en': {
        'translation': {
            'WELCOME1' : 'Welcome to bär leen!',
            'WELCOME2' : 'Greetings!',
            'WELCOME3' : 'Hello there!',
            'HELP'    : 'You can say help, stop, or cancel. ',
            'STOP'    : 'Goodbye!'
        }
    }
    , 'de-DE': {
        'translation' : {
            'WELCOME'   : 'Moin aus Irland.',
        }
    }
    , 'fr-FR': {
        'translation' : {
            'WELCOME'   : 'Japanese Welcome etc.'
        }
    }
};

//replace with respective Skill ID from dev console (OPTIONAL).
const APP_ID = 'amzn1.ask.skill.d7732837-fab2-42ff-a152-4eb0fc4ee646';

const Alexa = require("alexa-sdk");
const https = require("https");
const AWS = require("aws-sdk");
AWS.config.update({region: "eu-west-1"});


exports.handler = function(event, context, callback) {
    let alexa = Alexa.handler(event, context);
    // was changed from alexa.APP_ID in old API
    alexa.appId = APP_ID;

    alexa.resources = languageStrings;


    var locale = event.request.locale;
    console.log(event)
    // registration for a multiligual skill - will define speech output based on locale
    // an extended alexa.registerHandlers(handlers, h1, h2); //you can register multiple handlers at once like here
    if (locale == 'de-DE'){
        alexa.registerHandlers(DE_handlers);
        console.log('registered german handler');
    } else if (locale == 'fr-FR') {
        alexa.registerHandlers(FR_handlers);
        console.log('registered french handler');
    } else { //basically if locale.toString().startsWith('en')
        alexa.registerHandlers(EN_US_handlers);
        console.log('registered US-English handler');
    }

    // alexa.dynamoDBTableName = "myTable"; // persistent session attributes


    alexa.execute();
}

//the name we use to access this skill
//ber lin works better tan bär leen (has to consist of at least two words
// const invocationName = "bär leen";
const DE_handlers = {
    'AMAZON.CancelIntent': function () {
        this.response
            .speak('Tschüss');

        this.emit(':responseReady');
    },
    'AMAZON.HelpIntent': function () {

        var CustomIntents = getCustomIntents();
        var MyIntent = randomPhrase(CustomIntents);
        let say = 'Out of ' + CustomIntents.length + ' intents, here is one called, ' + MyIntent.name + ', just say, ' + MyIntent.samples[0];
        this.response
            .speak(say)
            .listen('try again, ' + say)
            .cardRenderer('Intent List', cardIntents(CustomIntents)); // , welcomeCardImg

        this.emit(':responseReady');
    },
    'AMAZON.StopIntent': function () {

        let say = 'Goodbye.';
        this.response
            .speak(say);

        this.emit(':responseReady');
    },
    'DL_ApprobationIntent': function () {
        // delegate to Alexa to collect all the required slots
        let isTestingWithSimulator = false; //autofill slots when using simulator, dialog management is only supported with a device
        let filledSlots = delegateSlotCollection.call(this, isTestingWithSimulator);

        if (!filledSlots) {
            return;
        }

        console.log("filled slots: " + JSON.stringify(filledSlots));
        // at this point, we know that all required slots are filled.
        let slotValues = getSlotValues(filledSlots);

        console.log(JSON.stringify(slotValues));


        let speechOutput = 'You have filled 2 required slots. ' +
            'BerufGesundheit resolved to,  ' + slotValues.BerufGesundheit.resolved + '. ' +
            'pruefungInBerlin resolved to,  ' + slotValues.pruefungInBerlin.resolved + '. ' ;

        console.log("Speech output: ", speechOutput);
        this.response.speak(speechOutput);
        this.emit(':responseReady');

        this.emit(':responseReady');
    },



    'DL_generalIntent': function () {
        // delegate to Alexa to collect all the required slots
        let isTestingWithSimulator = false; //autofill slots when using simulator, dialog management is only supported with a device
        let filledSlots = delegateSlotCollection.call(this, isTestingWithSimulator);

        if (!filledSlots) {
            return;
        }

        console.log("filled slots: " + JSON.stringify(filledSlots));
        // at this point, we know that all required slots are filled.
        let slotValues = getSlotValues(filledSlots);

        console.log(JSON.stringify(slotValues));


        let speechOutput = 'You have filled 3 required slots. ' +
            'Dienstleistung resolved to,  ' + slotValues.Dienstleistung.resolved + '. ' +
            'extension_flag resolved to,  ' + slotValues.extension_flag.resolved + '. ' +
            'prerequisites_flag resolved to,  ' + slotValues.prerequisites_flag.resolved + '. ' ;

        console.log("Speech output: ", speechOutput);
        this.response.speak(speechOutput);
        this.emit(':responseReady');

        this.emit(':responseReady');
    },
    'DL_AufenthaltstitelIntent': function () {
        // delegate to Alexa to collect all the required slots
        let isTestingWithSimulator = false; //autofill slots when using simulator, dialog management is only supported with a device
        let filledSlots = delegateSlotCollection.call(this, isTestingWithSimulator);

        if (!filledSlots) {
            return;
        }

        console.log("filled slots: " + JSON.stringify(filledSlots));
        // at this point, we know that all required slots are filled.
        let slotValues = getSlotValues(filledSlots);

        console.log(JSON.stringify(slotValues));


        let speechOutput = 'You have filled 5 required slots. ' +
            'registered_in_berlin resolved to,  ' + slotValues.registered_in_berlin.resolved + '. ' +
            'citizenship resolved to,  ' + slotValues.citizenship.resolved + '. ' +
            'residence_purpose resolved to,  ' + slotValues.residence_purpose.resolved + '. ' +
            'extension_flag resolved to,  ' + slotValues.extension_flag.resolved + '. ' +
            'prerequisites_flag resolved to,  ' + slotValues.prerequisites_flag.resolved + '. ' ;

        console.log("Speech output: ", speechOutput);
        this.response.speak(speechOutput);
        this.emit(':responseReady');

        this.emit(':responseReady');
    },
    'DL_BafoegIntent': function () {
        // delegate to Alexa to collect all the required slots
        let isTestingWithSimulator = false; //autofill slots when using simulator, dialog management is only supported with a device
        let filledSlots = delegateSlotCollection.call(this, isTestingWithSimulator);

        if (!filledSlots) {
            return;
        }

        console.log("filled slots: " + JSON.stringify(filledSlots));
        // at this point, we know that all required slots are filled.
        let slotValues = getSlotValues(filledSlots);

        console.log(JSON.stringify(slotValues));


        let speechOutput = 'You have filled 2 required slots. ' +
            'bafoegType resolved to,  ' + slotValues.bafoegType.resolved + '. ' +
            'prerequisites_flag resolved to,  ' + slotValues.prerequisites_flag.resolved + '. ' ;

        console.log("Speech output: ", speechOutput);
        this.response.speak(speechOutput);
        this.emit(':responseReady');

        this.emit(':responseReady');
    },
    'LOC_Intent': function () {
        let say = 'Hello from LOC_Intent. ';

        var slotStatus = '';
        var resolvedSlot;

        //   SLOT: office_type
        if (this.event.request.intent.slots.office_type.value) {
            const office_type = this.event.request.intent.slots.office_type;
            slotStatus += ' slot office_type was heard as ' + office_type.value + '. ';

            resolvedSlot = resolveCanonical(office_type);

            if(resolvedSlot != office_type.value) {
                slotStatus += ' which resolved to ' + resolvedSlot;
            }
        } else {
            slotStatus += ' slot office_type is empty. ';
        }

        //   SLOT: office_name
        if (this.event.request.intent.slots.office_name.value) {
            const office_name = this.event.request.intent.slots.office_name;
            slotStatus += ' slot office_name was heard as ' + office_name.value + '. ';

            resolvedSlot = resolveCanonical(office_name);

            if(resolvedSlot != office_name.value) {
                slotStatus += ' which resolved to ' + resolvedSlot;
            }
        } else {
            slotStatus += ' slot office_name is empty. ';
        }

        //   SLOT: district_single_name
        if (this.event.request.intent.slots.district_single_name.value) {
            const district_single_name = this.event.request.intent.slots.district_single_name;
            slotStatus += ' slot district_single_name was heard as ' + district_single_name.value + '. ';

            resolvedSlot = resolveCanonical(district_single_name);

            if(resolvedSlot != district_single_name.value) {
                slotStatus += ' which resolved to ' + resolvedSlot;
            }
        } else {
            slotStatus += ' slot district_single_name is empty. ';
        }

        //   SLOT: district_combo_name
        if (this.event.request.intent.slots.district_combo_name.value) {
            const district_combo_name = this.event.request.intent.slots.district_combo_name;
            slotStatus += ' slot district_combo_name was heard as ' + district_combo_name.value + '. ';

            resolvedSlot = resolveCanonical(district_combo_name);

            if(resolvedSlot != district_combo_name.value) {
                slotStatus += ' which resolved to ' + resolvedSlot;
            }
        } else {
            slotStatus += ' slot district_combo_name is empty. ';
        }


        say += slotStatus;

        this.response
            .speak(say)
            .listen('try again, ' + say)
            .cardRenderer('LOC_Intent', 'slot office_type is ' + office_type.value + '. slot office_name is ' + office_name.value + '. slot district_single_name is ' + district_single_name.value + '. slot district_combo_name is ' + district_combo_name.value + '. ');


        this.emit(':responseReady');
    },
    'ST_FutureTodos': function () {
        let say = 'Hello from ST_FutureTodos. ';

        var slotStatus = '';
        var resolvedSlot;

        //   SLOT: futureIntent
        if (this.event.request.intent.slots.futureIntent.value) {
            const futureIntent = this.event.request.intent.slots.futureIntent;
            slotStatus += ' slot futureIntent was heard as ' + futureIntent.value + '. ';

            resolvedSlot = resolveCanonical(futureIntent);

            if(resolvedSlot != futureIntent.value) {
                slotStatus += ' which resolved to ' + resolvedSlot;
            }
        } else {
            slotStatus += ' slot futureIntent is empty. ';
        }

        //   SLOT: DogName
        if (this.event.request.intent.slots.DogName.value) {
            const DogName = this.event.request.intent.slots.DogName;
            slotStatus += ' slot DogName was heard as ' + DogName.value + '. ';

            resolvedSlot = resolveCanonical(DogName);

            if(resolvedSlot != DogName.value) {
                slotStatus += ' which resolved to ' + resolvedSlot;
            }
        } else {
            slotStatus += ' slot DogName is empty. ';
        }


        say += slotStatus;

        this.response
            .speak(say)
            .listen('try again, ' + say)
            .cardRenderer('ST_FutureTodos', 'slot futureIntent is ' + futureIntent.value + '. slot DogName is ' + DogName.value + '. ');


        this.emit(':responseReady');
    },
    'ST_BerlinIntents': function () {
        let say = 'Hello from ST_BerlinIntents. ';

        this.response
            .speak(say)
            .listen('try again, ' + say)
            .cardRenderer('ST_BerlinIntents', '');


        this.emit(':responseReady');
    },
    'LaunchRequest': function () {
        let say = randomPhrase([this.t('WELCOME1'),this.t('WELCOME2'),this.t('WELCOME3')] )  + ' ' + this.t('HELP');
        this.response
            .speak(say)
            .listen('try again, ' + say);

        this.emit(':responseReady');
    },
    'Unhandled': function () {
        let say = 'The skill did not quite understand what you wanted.  Do you want to try something else? ';
        this.response
            .speak(say)
            .listen(say);
    }};









// Skill logic in English (US) =======================================================================================
// const invocationName = "berlin service";
const EN_US_handlers = {
    'AMAZON.CancelIntent': function () {

        let say = 'Goodbye.';
        this.response
            .speak(say);

        this.emit(':responseReady');
    },
    'AMAZON.HelpIntent': function () {

        var CustomIntents = getCustomIntents();
        var MyIntent = randomPhrase(CustomIntents);
        let say = 'Out of ' + CustomIntents.length + ' intents, here is one called, ' + MyIntent.name + ', just say, ' + MyIntent.samples[0];
        this.response
            .speak(say)
            .listen('try again, ' + say)
            .cardRenderer('Intent List', cardIntents(CustomIntents)); // , welcomeCardImg

        this.emit(':responseReady');
    },
    'AMAZON.StopIntent': function () {

        let say = 'Goodbye.';
        this.response
            .speak(say);

        this.emit(':responseReady');
    },
    'DL_AufenthaltstitelIntent': function () {
        let say = 'Hello from DL_AufenthaltstitelIntent. ';

        this.response
            .speak(say)
            .listen('try again, ' + say)
            .cardRenderer('DL_AufenthaltstitelIntent', '');


        this.emit(':responseReady');
    },
    'BafoegIntent': function () {
        let say = 'Hello from BafoegIntent. ';

        this.response
            .speak(say)
            .listen('try again, ' + say)
            .cardRenderer('BafoegIntent', '');


        this.emit(':responseReady');
    },
    'ApprobationIntent': function () {
        let say = 'Hello from ApprobationIntent. ';

        this.response
            .speak(say)
            .listen('try again, ' + say)
            .cardRenderer('ApprobationIntent', '');


        this.emit(':responseReady');
    },
    'DL_generalIntent': function () {
        // delegate to Alexa to collect all the required slots
        let isTestingWithSimulator = false; //autofill slots when using simulator, dialog management is only supported with a device
        let filledSlots = delegateSlotCollection.call(this, isTestingWithSimulator);

        if (!filledSlots) {
            return;
        }

        console.log("filled slots: " + JSON.stringify(filledSlots));
        // at this point, we know that all required slots are filled.
        let slotValues = getSlotValues(filledSlots);

        console.log(JSON.stringify(slotValues));


        let speechOutput = 'You have filled 1 required slots. ' +
            'prerequisites resolved to,  ' + slotValues.prerequisites.resolved + '. ' ;

        console.log("Speech output: ", speechOutput);
        this.response.speak(speechOutput);
        this.emit(':responseReady');

        this.emit(':responseReady');
    },
    'ST_BerlinQuestions': function () {
        let say = 'Hello from ST_BerlinQuestions. ';

        this.response
            .speak(say)
            .listen('try again, ' + say)
            .cardRenderer('ST_BerlinQuestions', '');


        this.emit(':responseReady');
    },
    'ST_FutureTODOs': function () {
        let say = 'Hello from ST_FutureTODOs. ';

        var slotStatus = '';
        var resolvedSlot;

        //   SLOT: DogName
        if (this.event.request.intent.slots.DogName.value) {
            const DogName = this.event.request.intent.slots.DogName;
            slotStatus += ' slot DogName was heard as ' + DogName.value + '. ';

            resolvedSlot = resolveCanonical(DogName);

            if(resolvedSlot != DogName.value) {
                slotStatus += ' which resolved to ' + resolvedSlot;
            }
        } else {
            slotStatus += ' slot DogName is empty. ';
        }

        //   SLOT: futureIntent
        if (this.event.request.intent.slots.futureIntent.value) {
            const futureIntent = this.event.request.intent.slots.futureIntent;
            slotStatus += ' slot futureIntent was heard as ' + futureIntent.value + '. ';

            resolvedSlot = resolveCanonical(futureIntent);

            if(resolvedSlot != futureIntent.value) {
                slotStatus += ' which resolved to ' + resolvedSlot;
            }
        } else {
            slotStatus += ' slot futureIntent is empty. ';
        }


        say += slotStatus;

        this.response
            .speak(say)
            .listen('try again, ' + say)
            .cardRenderer('ST_FutureTODOs', 'slot DogName is ' + DogName.value + '. slot futureIntent is ' + futureIntent.value + '. ');


        this.emit(':responseReady');
    },
    'LaunchRequest': function () {
        let say = randomPhrase([this.t('WELCOME1'),this.t('WELCOME2'),this.t('WELCOME3')] )  + ' ' + this.t('HELP');
        this.response
            .speak(say)
            .listen('try again, ' + say);

        this.emit(':responseReady');
    },
    'Unhandled': function () {
        let say = 'The skill did not quite understand what you wanted.  Do you want to try something else? ';
        this.response
            .speak(say)
            .listen(say);
    }};




//  ------ Helper Functions -----------------------------------------------

function randomPhrase(myArray) {
    return(myArray[Math.floor(Math.random() * myArray.length)]);
}

// returns slot resolved to an expected value if possible
function resolveCanonical(slot){
    try {
        var canonical = slot.resolutions.resolutionsPerAuthority[0].values[0].value.name;
    } catch(err){
        console.log(err.message);
        var canonical = slot.value;
    };
    return canonical;
};

// used to emit :delegate to elicit or confirm Intent Slots
function delegateSlotCollection(){
    console.log("current dialogState: " + this.event.request.dialogState);
    if (this.event.request.dialogState === "STARTED") {
        var updatedIntent = this.event.request.intent;

        this.emit(":delegate");

    } else if (this.event.request.dialogState !== "COMPLETED") {

        this.emit(":delegate");

    } else {
        console.log("returning: "+ JSON.stringify(this.event.request.intent));

        return this.event.request.intent;
    }
}

function getCustomIntents() {
    var customIntents = [];
    for (let i = 0; i < intentsReference.length; i++) {
        if(intentsReference[i].name.substring(0,7) != "AMAZON." && intentsReference[i].name !== "LaunchRequest" ) {
            customIntents.push(intentsReference[i]);
        }
    }
    return(customIntents);
}
function cardIntents(iArray) {
    var body = "";    for (var i = 0; i < iArray.length; i++) {
        body += iArray[i].name + "\n";
        body += "  '" + iArray[i].samples[0] + "'\n";
    }
    return(body);
}

const welcomeCardImg = {
    smallImageUrl: "https://m.media-amazon.com/images/G/01/mobile-apps/dex/alexa/alexa-skills-kit/alexa-devs-skill/cards/skill-builder-720x480._TTH_.png",
    largeImageUrl: "https://m.media-amazon.com/images/G/01/mobile-apps/dex/alexa/alexa-skills-kit/alexa-devs-skill/cards/skill-builder-1200x800._TTH_.png"
};


// ***********************************
// ** Helper functions from
// ** These should not need to be edited
// ** www.github.com/alexa/alexa-cookbook
// ***********************************

// ***********************************
// ** Route to Intent
// ***********************************

// after doing the logic in new session,
// route to the proper intent

function routeToIntent() {

    switch (this.event.request.type) {
        case 'IntentRequest':
            this.emit(this.event.request.intent.name);
            break;
        case 'LaunchRequest':
            this.emit('LaunchRequest');
            break;
        default:
            this.emit('LaunchRequest');
    }
}

// ***********************************
// ** Dialog Management
// ***********************************

function getSlotValues (filledSlots) {
    //given event.request.intent.slots, a slots values object so you have
    //what synonym the person said - .synonym
    //what that resolved to - .resolved
    //and if it's a word that is in your slot values - .isValidated
    let slotValues = {};

    console.log('The filled slots: ' + JSON.stringify(filledSlots));
    Object.keys(filledSlots).forEach(function(item) {
        //console.log("item in filledSlots: "+JSON.stringify(filledSlots[item]));
        var name = filledSlots[item].name;
        //console.log("name: "+name);
        if(filledSlots[item]&&
            filledSlots[item].resolutions &&
            filledSlots[item].resolutions.resolutionsPerAuthority[0] &&
            filledSlots[item].resolutions.resolutionsPerAuthority[0].status &&
            filledSlots[item].resolutions.resolutionsPerAuthority[0].status.code ) {

            switch (filledSlots[item].resolutions.resolutionsPerAuthority[0].status.code) {
                case "ER_SUCCESS_MATCH":
                    slotValues[name] = {
                        "synonym": filledSlots[item].value,
                        "resolved": filledSlots[item].resolutions.resolutionsPerAuthority[0].values[0].value.name,
                        "isValidated": true
                    };
                    break;
                case "ER_SUCCESS_NO_MATCH":
                    slotValues[name] = {
                        "synonym": filledSlots[item].value,
                        "resolved": filledSlots[item].value,
                        "isValidated":false
                    };
                    break;
            }
        } else {
            slotValues[name] = {
                "synonym": filledSlots[item].value,
                "resolved": filledSlots[item].value,
                "isValidated": false
            };
        }
    },this);
    //console.log("slot values: "+JSON.stringify(slotValues));
    return slotValues;
}
// This function delegates multi-turn dialogs to Alexa.
// For more information about dialog directives see the link below.
// https://developer.amazon.com/docs/custom-skills/dialog-interface-reference.html
function delegateSlotCollection() {
    console.log("in delegateSlotCollection");
    console.log("current dialogState: " + this.event.request.dialogState);

    if (this.event.request.dialogState === "STARTED") {
        console.log("in STARTED");
        console.log(JSON.stringify(this.event));
        var updatedIntent=this.event.request.intent;
        // optionally pre-fill slots: update the intent object with slot values
        // for which you have defaults, then return Dialog.Delegate with this
        // updated intent in the updatedIntent property

        disambiguateSlot.call(this);
        console.log("disambiguated: " + JSON.stringify(this.event));
        this.emit(":delegate", updatedIntent);
    } else if (this.event.request.dialogState !== "COMPLETED") {
        console.log("in not completed");
        //console.log(JSON.stringify(this.event));

        disambiguateSlot.call(this);
        this.emit(":delegate", updatedIntent);
    } else {
        console.log("in completed");
        //console.log("returning: "+ JSON.stringify(this.event.request.intent));
        // Dialog is now complete and all required slots should be filled,
        // so call your normal intent handler.
        return this.event.request.intent.slots;
    }
    return null;
}
// If the user said a synonym that maps to more than one value, we need to ask
// the user for clarification. Disambiguate slot will loop through all slots and
// elicit confirmation for the first slot it sees that resolves to more than
// one value.
function disambiguateSlot() {
    let currentIntent = this.event.request.intent;

    Object.keys(this.event.request.intent.slots).forEach(function(slotName) {
        let currentSlot = this.event.request.intent.slots[slotName];
        let slotValue = slotHasValue(this.event.request, currentSlot.name);
        if (currentSlot.confirmationStatus !== 'CONFIRMED' &&
            currentSlot.resolutions &&
            currentSlot.resolutions.resolutionsPerAuthority[0]) {

            if (currentSlot.resolutions.resolutionsPerAuthority[0].status.code == 'ER_SUCCESS_MATCH') {
                // if there's more than one value that means we have a synonym that
                // mapped to more than one value. So we need to ask the user for
                // clarification. For example if the user said "mini dog", and
                // "mini" is a synonym for both "small" and "tiny" then ask "Did you
                // want a small or tiny dog?" to get the user to tell you
                // specifically what type mini dog (small mini or tiny mini).
                if ( currentSlot.resolutions.resolutionsPerAuthority[0].values.length > 1) {
                    let prompt = 'Which would you like';
                    let size = currentSlot.resolutions.resolutionsPerAuthority[0].values.length;
                    currentSlot.resolutions.resolutionsPerAuthority[0].values.forEach(function(element, index, arr) {
                        prompt += ` ${(index == size -1) ? ' or' : ' '} ${element.value.name}`;
                    });

                    prompt += '?';
                    let reprompt = prompt;
                    // In this case we need to disambiguate the value that they
                    // provided to us because it resolved to more than one thing so
                    // we build up our prompts and then emit elicitSlot.
                    this.emit(':elicitSlot', currentSlot.name, prompt, reprompt);
                }
            } else if (currentSlot.resolutions.resolutionsPerAuthority[0].status.code == 'ER_SUCCESS_NO_MATCH') {
                // Here is where you'll want to add instrumentation to your code
                // so you can capture synonyms that you haven't defined.
                console.log("NO MATCH FOR: ", currentSlot.name, " value: ", currentSlot.value);

                if (REQUIRED_SLOTS.indexOf(currentSlot.name) > -1) {
                    let prompt = "What " + currentSlot.name + " are you looking for";
                    this.emit(':elicitSlot', currentSlot.name, prompt, prompt);
                }
            }
        }
    }, this);
}

// Given the request an slot name, slotHasValue returns the slot value if one
// was given for `slotName`. Otherwise returns false.
function slotHasValue(request, slotName) {

    let slot = request.intent.slots[slotName];

    //uncomment if you want to see the request
    //console.log("request = "+JSON.stringify(request));
    let slotValue;

    //if we have a slot, get the text and store it into speechOutput
    if (slot && slot.value) {
        //we have a value in the slot
        slotValue = slot.value.toLowerCase();
        return slotValue;
    } else {
        //we didn't get a value in the slot.
        return false;
    }
}












// End Skill Code
// Language Model  for reference
var interactionModel = [
    {
        "name": "AMAZON.CancelIntent",
        "samples": []
    },
    {
        "name": "AMAZON.HelpIntent",
        "samples": []
    },
    {
        "name": "AMAZON.StopIntent",
        "samples": []
    },
    {
        "name": "DL_AufenthaltstitelIntent",
        "slots": [],
        "samples": []
    },
    {
        "name": "BafoegIntent",
        "slots": [],
        "samples": []
    },
    {
        "name": "ApprobationIntent",
        "slots": [],
        "samples": []
    },
    {
        "name": "DL_generalIntent",
        "slots": [
            {
                "name": "Dienstleistung",
                "type": "EN_LIST_OF_PUBLIC_SVCS_BLN"
            },
            {
                "name": "prerequisites",
                "type": "EN_YES_NO_FLAG",
                "samples": [
                    "{prerequisites} please"
                ]
            }
        ],
        "samples": [
            "how do i {Dienstleistung}",
            "i want to {Dienstleistung}",
            "i would like to {Dienstleistung}"
        ]
    },
    {
        "name": "ST_BerlinQuestions",
        "slots": [],
        "samples": []
    },
    {
        "name": "ST_FutureTODOs",
        "slots": [
            {
                "name": "DogName",
                "type": "AMAZON.US_FIRST_NAME"
            },
            {
                "name": "futureIntent",
                "type": "Todo_List"
            }
        ],
        "samples": [
            "I need an apartment",
            "where can I {futureIntent}",
            "I want to go bathing",
            "I need a house",
            "I lost my Meldebscheinigung",
            "where do I find {DogName}",
            "where did my dog go",
            "where do I find my lost dog",
            "how can I find my dog",
            "I lost my dog",
            "ich habe ein Kind bekommen wo kann ich eine geburtsurkunde beantragen"
        ]
    },
    {
        "name": "LaunchRequest"
    }
];
var intentsReference = [
    {
        "name": "AMAZON.CancelIntent",
        "samples": []
    },
    {
        "name": "AMAZON.HelpIntent",
        "samples": []
    },
    {
        "name": "AMAZON.StopIntent",
        "samples": []
    },
    {
        "name": "DL_AufenthaltstitelIntent",
        "slots": [],
        "samples": []
    },
    {
        "name": "BafoegIntent",
        "slots": [],
        "samples": []
    },
    {
        "name": "ApprobationIntent",
        "slots": [],
        "samples": []
    },
    {
        "name": "DL_generalIntent",
        "slots": [
            {
                "name": "Dienstleistung",
                "type": "EN_LIST_OF_PUBLIC_SVCS_BLN"
            },
            {
                "name": "prerequisites",
                "type": "EN_YES_NO_FLAG",
                "samples": [
                    "{prerequisites} please"
                ]
            }
        ],
        "samples": [
            "how do i {Dienstleistung}",
            "i want to {Dienstleistung}",
            "i would like to {Dienstleistung}"
        ]
    },
    {
        "name": "ST_BerlinQuestions",
        "slots": [],
        "samples": []
    },
    {
        "name": "ST_FutureTODOs",
        "slots": [
            {
                "name": "DogName",
                "type": "AMAZON.US_FIRST_NAME"
            },
            {
                "name": "futureIntent",
                "type": "Todo_List"
            }
        ],
        "samples": [
            "I need an apartment",
            "where can I {futureIntent}",
            "I want to go bathing",
            "I need a house",
            "I lost my Meldebscheinigung",
            "where do I find {DogName}",
            "where did my dog go",
            "where do I find my lost dog",
            "how can I find my dog",
            "I lost my dog",
            "ich habe ein Kind bekommen wo kann ich eine geburtsurkunde beantragen"
        ]
    },
    {
        "name": "LaunchRequest"
    }
];















// /* eslint-disable  func-names */
// /* eslint quote-props: ["error", "consistent"]*/
// /**
//  * This sample demonstrates a simple skill built with the Amazon Alexa Skills
//  * nodejs skill development kit.
//  * This sample supports multiple lauguages. (en-US, en-GB, de-DE).
//  * The Intent Schema, Custom Slots and Sample Utterances for this skill, as well
//  * as testing instructions are located at https://github.com/alexa/skill-sample-nodejs-fact
//  **/

// 'use strict';
// const Alexa = require('alexa-sdk');

// //=========================================================================================================================================
// //TODO: The items below this comment need your attention.
// //=========================================================================================================================================

// //Replace with your app ID (OPTIONAL).  You can find this value at the top of your skill's page on http://developer.amazon.com.
// //Make sure to enclose your value in quotes, like this: const APP_ID = 'amzn1.ask.skill.bb4045e6-b3e8-4133-b650-72923c5980f1';
// const APP_ID = undefined;

// const SKILL_NAME = 'Space Facts';
// const GET_FACT_MESSAGE = "Here's your fact: ";
// const HELP_MESSAGE = 'You can say tell me a space fact, or, you can say exit... What can I help you with?';
// const HELP_REPROMPT = 'What can I help you with?';
// const STOP_MESSAGE = 'Goodbye!';

// //=========================================================================================================================================
// //TODO: Replace this data with your own.  You can find translations of this data at http://github.com/alexa/skill-sample-node-js-fact/data
// //=========================================================================================================================================
// const data = [
//     'A year on Mercury is just 88 days long.',
//     'Despite being farther from the Sun, Venus experiences higher temperatures than Mercury.',
//     'Venus rotates counter-clockwise, possibly because of a collision in the past with an asteroid.',
//     'On Mars, the Sun appears about half the size as it does on Earth.',
//     'Earth is the only planet not named after a god.',
//     'Jupiter has the shortest day of all the planets.',
//     'The Milky Way galaxy will collide with the Andromeda Galaxy in about 5 billion years.',
//     'The Sun contains 99.86% of the mass in the Solar System.',
//     'The Sun is an almost perfect sphere.',
//     'A total solar eclipse can happen once every 1 to 2 years. This makes them a rare event.',
//     'Saturn radiates two and a half times more energy into space than it receives from the sun.',
//     'The temperature inside the Sun can reach 15 million degrees Celsius.',
//     'The Moon is moving approximately 3.8 cm away from our planet every year.',
// ];

// //=========================================================================================================================================
// //Editing anything below this line might break your skill.
// //=========================================================================================================================================

// const handlers = {
//     'LaunchRequest': function () {
//         this.emit('GetNewFactIntent');
//     },
//     'GetNewFactIntent': function () {
//         const factArr = data;
//         const factIndex = Math.floor(Math.random() * factArr.length);
//         const randomFact = factArr[factIndex];
//         const speechOutput = GET_FACT_MESSAGE + randomFact;

//         this.response.cardRenderer(SKILL_NAME, randomFact);
//         this.response.speak(speechOutput);
//         this.emit(':responseReady');
//     },
//     'AMAZON.HelpIntent': function () {
//         const speechOutput = HELP_MESSAGE;
//         const reprompt = HELP_REPROMPT;

//         this.response.speak(speechOutput).listen(reprompt);
//         this.emit(':responseReady');
//     },
//     'AMAZON.CancelIntent': function () {
//         this.response.speak(STOP_MESSAGE);
//         this.emit(':responseReady');
//     },
//     'AMAZON.StopIntent': function () {
//         this.response.speak(STOP_MESSAGE);
//         this.emit(':responseReady');
//     },
// };

// exports.handler = function (event, context, callback) {
//     const alexa = Alexa.handler(event, context, callback);
//     alexa.APP_ID = APP_ID;
//     alexa.registerHandlers(handlers);
//     alexa.execute();
// };
