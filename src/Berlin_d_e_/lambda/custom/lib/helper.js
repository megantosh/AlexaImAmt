// Author: Mohamed Megahed
// blueprint code for intents generated by SkillCode. based on the Fact blueprint.
// http://alexa.design/skillcode


//use after-load for pages with JavaScript, simulates browser behaviour
const https = require("https");
//alternatively, use fetch module in case of cookies handling, redirect etc
//const fetchUrl = require("fetch").fetchUrl;

const langStrings = require("alexa-sdk")

exports.handler = function(event, context, callback) {
    let alexa = Alexa.handler(event, context);
    // was changed from alexa.APP_ID in old API
    alexa.appId = APP_ID;

    //alexa.resources = Speech.defaultSpokenStrings;



}



//TODO read about what each of them says and explain here:
//https://github.com/alexa/alexa-skills-kit-sdk-for-nodejs/blob/master/Readme.md
exports.nodeEvents = {

    //Called after the response is built but before it is returned to the Alexa service. Calls :saveState.
    RESPONSE_READY : ':responseReady',


    DELEGATE : ':delegate',


    //old ones

    //this.emit(':tell', speechOutput);
    TELL : ':tell',

    //
    //use:
    //this.emit(':ask', speechOutput, repromptSpeech);
    ASK : ':ask',

    SPEAK : ':speak',

    //this.emit(':askWithCard', speechOutput, repromptSpeech, cardTitle, cardContent, imageObj);
    ASK_WITH_CARD : ':askWithCard',

    //this.emit(':tellWithCard', speechOutput, cardTitle, cardContent, imageObj);
    TELL_WITH_CARD : ':tellWithCard',


    TELL_WITH_ACCT_CARD :'tellWithLinkAccountCard',
    ASK_WITH_ACCT_CARD: ':askWithLinkAccountCard',



    //this.emit(':saveState', false); // Handles saving the contents of this.attributes and the current handler state to DynamoDB and then sends the previously built response to the Alexa service. Override if you wish to use a different persistence provider. The second attribute is optional and can be set to ‘true’ to force saving.
    SAVE_STATE : ':saveState',

    // Called if there is an error while saving state. Override to handle any errors yourself.
    //this.emit(':saveStateError');




// ASK_FOR_PERMISSIONS_CONSENT:
}





//  ==== Code Patterns ===============================================================================================

// format:
// this.emit(:${action}, 'responseContent').
// {
//     //event, answer
//     this.emit(':tell', 'Hello World!');
//     //event, prompt, reprompt
//     this.emit(':ask', 'What would you like to do?', 'Please say that again?');
// }
// {
//     this.response.speak('Hello World!');
//     this.emit(':responseReady');
//
//     this.response.speak('What would you like to do?')
//         .listen('Please say that again?');
//     this.emit(':responseReady');
// }



//  ===== Helper Functions partially from AWS =========================================================================

exports.randomphrase = function randomPhrase(myArray) {
    return(myArray[Math.floor(Math.random() * myArray.length)]);
}

// returns slot resolved to an expected value if possible
exports.resolveCanonical = function resolveCanonical(slot){
    try {
        var canonical = slot.resolutions.resolutionsPerAuthority[0].values[0].value.name;
    } catch(err){
        console.log(err.message);
        var canonical = slot.value;
    };
    return canonical;
};

// used to emit :delegate to elicit or confirm Intent Slots
exports.delegateSlotCollection = function delegateSlotCollection(){
    console.log("current dialogState: " + this.event.request.dialogState);
    if (this.event.request.dialogState === "STARTED") {
        var updatedIntent = this.event.request.intent;

        this.emit(":delegate");

    } else if (this.event.request.dialogState !== "COMPLETED") {

        this.emit(":delegate");

    } else {
        console.log("returning: "+ JSON.stringify(this.event.request.intent));

        return this.event.request.intent;
    }
}

exports.getCustomIntents = function getCustomIntents() {
    var customIntents = [];
    for (let i = 0; i < intentsReference.length; i++) {
        if(intentsReference[i].name.substring(0,7) != "AMAZON." && intentsReference[i].name !== "LaunchRequest" ) {
            customIntents.push(intentsReference[i]);
        }
    }
    return(customIntents);
}
exports.cardIntents = function cardIntents(iArray) {
    var body = "";    for (var i = 0; i < iArray.length; i++) {
        body += iArray[i].name + "\n";
        body += "  '" + iArray[i].samples[0] + "'\n";
    }
    return(body);
}



// ***********************************
// ** Helper functions from
// ** These should not need to be edited
// ** www.github.com/alexa/alexa-cookbook
// ***********************************

// ***********************************
// ** Route to Intent
// ***********************************

// after doing the logic in new session,
// route to the proper intent

exports.routeToIntent = function routeToIntent() {

    switch (this.event.request.type) {
        case 'IntentRequest':
            this.emit(this.event.request.intent.name);
            break;
        case 'LaunchRequest':
            this.emit('LaunchRequest');
            break;
        default:
            this.emit('LaunchRequest');
    }
}

// ***********************************
// ** Dialog Management
// ***********************************

exports.getSlotValues = function getSlotValues (filledSlots) {
    //given event.request.intent.slots, a slots values object so you have
    //what synonym the person said - .synonym
    //what that resolved to - .resolved
    //and if it's a word that is in your slot values - .isValidated
    let slotValues = {};

    console.log('The filled slots: ' + JSON.stringify(filledSlots));
    Object.keys(filledSlots).forEach(function(item) {
        //console.log("item in filledSlots: "+JSON.stringify(filledSlots[item]));
        var name = filledSlots[item].name;
        //console.log("name: "+name);
        if(filledSlots[item]&&
            filledSlots[item].resolutions &&
            filledSlots[item].resolutions.resolutionsPerAuthority[0] &&
            filledSlots[item].resolutions.resolutionsPerAuthority[0].status &&
            filledSlots[item].resolutions.resolutionsPerAuthority[0].status.code ) {

            switch (filledSlots[item].resolutions.resolutionsPerAuthority[0].status.code) {
                case "ER_SUCCESS_MATCH":
                    slotValues[name] = {
                        "synonym": filledSlots[item].value,
                        "resolved": filledSlots[item].resolutions.resolutionsPerAuthority[0].values[0].value.name,
                        "isValidated": true
                    };
                    break;
                case "ER_SUCCESS_NO_MATCH":
                    slotValues[name] = {
                        "synonym": filledSlots[item].value,
                        "resolved": filledSlots[item].value,
                        "isValidated":false
                    };
                    break;
            }
        } else {
            slotValues[name] = {
                "synonym": filledSlots[item].value,
                "resolved": filledSlots[item].value,
                "isValidated": false
            };
        }
    },this);
    //console.log("slot values: "+JSON.stringify(slotValues));
    return slotValues;
}
// This function delegates multi-turn dialogs to Alexa.
// For more information about dialog directives see the link below.
// https://developer.amazon.com/docs/custom-skills/dialog-interface-reference.html
exports.delegateSlotCollection = function delegateSlotCollection(currentLocale) {
    console.log("in delegateSlotCollection");
    console.log("current dialogState: " + this.event.request.dialogState);

    if (this.event.request.dialogState === "STARTED") {
        console.log("in STARTED");
        console.log(JSON.stringify(this.event));
        var updatedIntent=this.event.request.intent;
        // optionally pre-fill slots: update the intent object with slot values
        // for which you have defaults, then return Dialog.Delegate with this
        // updated intent in the updatedIntent property

        disambiguateSlot(currentLocale).call(this);
        console.log("disambiguated: " + JSON.stringify(this.event));
        this.emit(":delegate", updatedIntent);
    } else if (this.event.request.dialogState !== "COMPLETED") {
        console.log("in not completed");
        //console.log(JSON.stringify(this.event));

        disambiguateSlot(currentLocale).call(this);
        this.emit(":delegate", updatedIntent);
    } else {
        console.log("in completed");
        //console.log("returning: "+ JSON.stringify(this.event.request.intent));
        // Dialog is now complete and all required slots should be filled,
        // so call your normal intent handler.
        return this.event.request.intent.slots;
    }
    return null;
}
// If the user said a synonym that maps to more than one value, we need to ask
// the user for clarification. Disambiguate slot will loop through all slots and
// elicit confirmation for the first slot it sees that resolves to more than
// one value.
function disambiguateSlot(currLoc) {
    let currentIntent = this.event.request.intent;

    Object.keys(this.event.request.intent.slots).forEach(function(slotName) {
        let currentLocale = currLoc;
        let currentSlot = this.event.request.intent.slots[slotName];
        let slotValue = slotHasValue(this.event.request, currentSlot.name);
        if (currentSlot.confirmationStatus !== 'CONFIRMED' &&
            currentSlot.resolutions &&
            currentSlot.resolutions.resolutionsPerAuthority[0]) {

            if (currentSlot.resolutions.resolutionsPerAuthority[0].status.code == 'ER_SUCCESS_MATCH') {
                // if there's more than one value that means we have a synonym that
                // mapped to more than one value. So we need to ask the user for
                // clarification. For example if the user said "mini dog", and
                // "mini" is a synonym for both "small" and "tiny" then ask "Did you
                // want a small or tiny dog?" to get the user to tell you
                // specifically what type mini dog (small mini or tiny mini).
                if ( currentSlot.resolutions.resolutionsPerAuthority[0].values.length > 1) {

                    //TODO give based on language
                    let localePrompt;

                    if (currentLocale === 'de-DE'){
                        localePrompt = 'ich habe mehrere Treffer';
                    } else if (currentLocale === 'en-US') {
                        localePrompt =  'Which would you like';
                    }
                    let prompt = localePrompt;
                    let size = currentSlot.resolutions.resolutionsPerAuthority[0].values.length;
                    currentSlot.resolutions.resolutionsPerAuthority[0].values.forEach(function(element, index, arr) {
                        prompt += ` ${(index == size -1) ? ' or' : ' '} ${element.value.name}`;
                    });

                    prompt += '?';
                    let reprompt = prompt;
                    // In this case we need to disambiguate the value that they
                    // provided to us because it resolved to more than one thing so
                    // we build up our prompts and then emit elicitSlot.
                    this.emit(':elicitSlot', currentSlot.name, prompt, reprompt);
                }
            } else if (currentSlot.resolutions.resolutionsPerAuthority[0].status.code == 'ER_SUCCESS_NO_MATCH') {
                // Here is where you'll want to add instrumentation to your code
                // so you can capture synonyms that you haven't defined.
                console.log("NO MATCH FOR: ", currentSlot.name, " value: ", currentSlot.value);

                if (REQUIRED_SLOTS.indexOf(currentSlot.name) > -1) {
                    let prompt = "What " + currentSlot.name + " are you looking for";
                    this.emit(':elicitSlot', currentSlot.name, prompt, prompt);
                }
            }
        }
    }, this);
}

// Given the request an slot name, slotHasValue returns the slot value if one
// was given for `slotName`. Otherwise returns false.
function slotHasValue(request, slotName) {

    let slot = request.intent.slots[slotName];

    //uncomment if you want to see the request
    //console.log("request = "+JSON.stringify(request));
    let slotValue;

    //if we have a slot, get the text and store it into speechOutput
    if (slot && slot.value) {
        //we have a value in the slot
        slotValue = slot.value.toLowerCase();
        return slotValue;
    } else {
        //we didn't get a value in the slot.
        return false;
    }
}




//TODO twilio SMS with link to book appointment page (CAPTCHA is in the way),

//TODO parser to tell alexa which is the next free appointment...
//this is possible with the class calendar on the website
// siehe Note #hhibody > div:nth-child(3) > div.collapsible-body > div.calendar-table > div.row-fluid







// ***********************************
// ** Webservice Calls
// ***********************************

// make an http get request calls resolve upon completion and reject if there's an error.
// returns a promise -
exports.httpGet = function httpGet(options){
    return new Promise(function(resolve, reject) {
        let request = https.request(options, response => {
            response.setEncoding('utf8');
            let returnData = "";

            if (response.statusCode < 200 || response.statusCode >= 300) {
                // we must return in this case
                // otherwise reject runs on the next tick and we'll get an error
                // when res.on('end') tries to parse the JSON.
                return reject(new Error(`${response.statusCode}: ${response.req.getHeader('host')} ${response.req.path}`));
            }

            response.on('data', chunk => {
                returnData = returnData + chunk;
            });

            response.on('end', () => {
                // we have now received the raw return data in the returnData variable.
                // We can see it in the log output via:
                // console.log(JSON.stringify(returnData))
                // we may need to parse through it to extract the needed data

                let response = JSON.parse(returnData);
                // this will execute whatever the block of code that was passed to
                // httpGet and pass the JSON `response` to it.
                resolve(response);
            });

            response.on('error', error => {
                reject(error);
            });
        });
        request.end();
    });
}

// Creates the options object for an HTTPs GET Request
// Returns an object.
exports.buildHttpGetOptions = function buildHttpGetOptions(host, path, port) { //, params) {
    let options = {
        hostname: host,
        path: path, //+ buildQueryString(params),
        port: port,
        method: 'GET'
    };
    return options;
}


//TODO might (not) need export! - complete with petmatch params
// Given a list of parameters it builds the query string for a request.
// Returns URI encoded string of parameters.
function buildQueryString(params) {
    let paramList = '';
    params.forEach( (paramGroup, index) => {
        paramList += `${ index == 0 ? '?' : '&'}${encodeURIComponent(paramGroup[0])}=${encodeURIComponent(paramGroup[1])}`;
    });
    return paramList;

}
